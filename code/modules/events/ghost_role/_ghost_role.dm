#define MAX_SPAWN_ATTEMPT 3


/datum/round_event/ghost_role
	fakeable = FALSE
	/// Members of this list will be placed at the front of the candicacy list, in front of the (shuffled) normal candidates.
	var/list/priority_candidates = list() //expected to contain 0 or more /clients (or things with .key)
	/// The minimum number of signups required for the event to continue past the polling period
	var/minimum_required = 1
	/// The name of the role, to be displayed in logs/polls/etc.
	var/role_name = "debug rat with cancer" // Q U A L I T Y  M E M E S
	/// A list of mobs generated by this event.
	var/list/spawned_mobs = list()
	/// Used to communicate the progress of the event firing, and whether or not the event was successfuly run.
	var/status
	/// A stored value of the event's announcement chance. Cached and not immediately used to prevent announcements for a failed event roll.
	var/cached_announcement_chance
	/// Is our ghost role sensitive to atmospherics? Used when finding spawns. Currently a var, will be changed to a better system later hopefully
	var/atmos_sensitive = FALSE

/datum/round_event/ghost_role/start()
	try_spawning()

/**
 * Attempts to spawn the role, and cancels the event if it fails.
 *
 * Pauses the event right as it begins, and waits for setup/polling to end.
 * If successful, continues running the rest of the event and notifies ghosts.
 */

/datum/round_event/ghost_role/proc/try_spawning()
	// The event does not run until the spawning has been attempted
	// to prevent us from getting gc'd halfway through
	processing = FALSE

	status = spawn_role()
	if(isnull(cached_announcement_chance))
		cached_announcement_chance = announce_chance //only announce once we've finished the spawning loop.
	announce_chance = (status == SUCCESSFUL_SPAWN ? cached_announcement_chance : 0)
	if((status == WAITING_FOR_SOMETHING))
		var/retry_count = 0
		if(retry_count >= MAX_SPAWN_ATTEMPT)
			message_admins("[role_name] event has exceeded maximum spawn attempts. Aborting and refunding.")
			if(control && control.occurrences > 0) //Don't refund if it hasn't
				control.occurrences--
			return
		var/waittime = 300 * (2**retry_count)
		message_admins("The event will not spawn a [role_name] until certain \
			conditions are met. Waiting [waittime/10]s and then retrying.")
		addtimer(CALLBACK(src, PROC_REF(try_spawning), 0, ++retry_count), waittime)
		return

	if(!status)
		message_admins("An attempt to spawn [role_name] returned [status], this is a bug.")
		kill()
		return

	switch(status)
		if(MAP_ERROR)
			message_admins("[role_name] cannot be spawned due to a map error.")
			kill()
			return
		if(NOT_ENOUGH_PLAYERS)
			message_admins("[role_name] cannot be spawned due to lack of players signing up.")
			deadchat_broadcast(" did not get enough candidates ([minimum_required]) to spawn.", "<b>[role_name]</b>", message_type=DEADCHAT_ANNOUNCEMENT)
			kill()
			return
		if(SUCCESSFUL_SPAWN)
			message_admins("[role_name] spawned successfully.")
			if(spawned_mobs.len)
				for (var/mob/mobs as anything in spawned_mobs)
					announce_to_ghosts(mobs)
			else
				message_admins("No mobs found in the `spawned_mobs` list, this is a bug.")

	processing = TRUE

/**
 * Performs the spawning of our role. Entirely specific to the event itself.
 *
 * Should return SUCCESSFUL_SPAWN if role was successfully spawned,
 * return NOT_ENOUGH_PLAYERS if less than mimimum_required was found,
 * and return MAP_ERROR if a spawn location could not be found.
 */

/datum/round_event/ghost_role/proc/spawn_role()
	return FALSE

/**
 * Gathers the candidates to select our ghost roles from.
 *
 * Returns a list of candidates in priority order, with candidates from
 * `priority_candidates` first, and ghost roles randomly shuffled and
 * appended after.
 *
 * jobban - The jobban flag to exclude players from the polling pool with.
 * be_special - The "special role" flag for the ghost candidacy poll.
 */

/datum/round_event/ghost_role/proc/get_candidates(jobban, be_special)
	var/list/mob/dead/observer/regular_candidates
	// don't get their hopes up
	if(priority_candidates.len < minimum_required)
		regular_candidates = poll_ghost_candidates("Do you wish to be considered for the special role of '[role_name]'?", jobban, be_special)
	else
		regular_candidates = list()

	shuffle_inplace(regular_candidates)

	var/list/candidates = priority_candidates + regular_candidates

	return candidates

/**
 * Finds us a generic maintenance spawn location.
 *
 * Goes through the list of the generic mainteance landmark locations, checking for atmos safety if required, and returns
 * a valid turf. Returns MAP_ERROR if no valid locations are present.
 */

/datum/round_event/ghost_role/proc/find_maintenance_spawn()
	var/list/possible_spawns = list()
	for(var/spawn_location in GLOB.generic_maintenance_landmarks)
		var/turf/spawn_turf = get_turf(spawn_location)

		if(atmos_sensitive && !is_safe_turf(spawn_turf))
			continue

		possible_spawns += spawn_turf

	if(!length(possible_spawns))
		message_admins("No valid generic_maintenance_landmark landmarks found, aborting...")
		return MAP_ERROR

	return pick(possible_spawns)

/**
 * Finds us a generic spawn location in space.
 *
 * Goes through the list of the space carp spawn locations, picks from the list, and
 * returns that turf. Returns MAP_ERROR if no landmarks are found.
 */

/datum/round_event/ghost_role/proc/find_space_spawn()
	var/list/possible_spawns = list()
	for(var/obj/effect/landmark/carpspawn/spawn_location in GLOB.landmarks_list)
		if(!isturf(spawn_location.loc))
			stack_trace("Carp spawn found not on a turf: [spawn_location.type] on [isnull(spawn_location.loc) ? "null" : spawn_location.loc.type]")
			continue
		possible_spawns += get_turf(spawn_location)

	if(!length(possible_spawns))
		message_admins("No valid carpspawn landmarks found, aborting...")
		return MAP_ERROR

	return pick(possible_spawns)

#undef MAX_SPAWN_ATTEMPT
