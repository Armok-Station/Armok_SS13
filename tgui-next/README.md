# tgui-next

## Introduction

tgui is a robust user interface framework of /tg/station. It is rendered
completely in the browser, based on JSON data sent from the server.
This data flow is always unidirectional, and the only way to make changes
to the game state is to dispatch actions which are processed on the server,
in a similar method to native BYOND Topic(). Once the action is processed,
an updated JSON is sent.

tgui is very different from most UIs you will encounter in BYOND programming,
and is heavily reliant of Javascript and web technologies as opposed to DM.
However, if you are familiar with NanoUI (a library which can be found on almost
every other SS13 codebase), tgui should be fairly easy to pick up.

tgui is a fork of an older tgui (based on Ractive), which is a fork of NanoUI.
The server-side code (DM) is similar and derived from NanoUI, while the
clientside is a wholly new project with no code in common.

To get a clearer picture how to create a completely new interface from scratch,
please refer to this [backend tutorial document](docs/tutorial-and-examples.md).
If you don't know how backend works, or have very little knowledge about
both frontend and backend, or simply want a step by step instruction,
we recommend you first read the document linked above.

This project uses **Inferno** - a very fast UI rendering engine with a similar
API to React. If you are new to Inferno or React, take your time to read
these documents:

- [React guide](https://reactjs.org/docs/hello-world.html)
- [Inferno documentation](https://infernojs.org/docs/guides/components) -
highlights differences with React.

## Pre-requisites

You will need these programs to start developing in frontend:

- [Node 12.x](https://nodejs.org)
- [Yarn](https://yarnpkg.com)
- [MSys2](https://www.msys2.org/) (optional)

## Workflow

For MSys2 or Linux/Mac users:

- `./build.sh` - build the project in production mode
- `./build.sh --dev` - launch a development server
- `./build.sh --lint` - show and fix potential problems the with code
- `./build.sh --analyze` - run a bundle analyzer

For everyone else:

Run `yarn install`, then:

- `yarn run build` - build the project in production mode
- `yarn run watch` - launch a development server
- `yarn run lint` - show and fix potential problems with the code
- `yarn run analyze` - run a bundle analyzer

## Project structure

- `/packages` - home for reusable bits of functionality, where each folder
is a self-contained node module.
- `/packages/tgui/index.js` - Application entry point.
- `/packages/tgui/components` - Basic UI building blocks.
- `/packages/tgui/interfaces` - Actual in-game interfaces.
Take JSON data via the `state` prop and output an html-like stucture,
which you can build using already existing UI components, such as buttons,
boxes, labeled lists and other things.
- `/packages/tgui/layout.js` - A root-level component, this is where you want
to register new interfaces, otherwise they simply won't load.

## Introduction to the component system

This component framework is inspired by:

- [Semantic UI](https://react.semantic-ui.com/), which felt great because it
has a very terse syntax and human readable naming system. Some things
like `as`, `content` props, and shorthand binary props, all are inspired
straight from this framework.
- [Material UI](https://material-ui.com/components/box/), which has a very
good API, mainly for it's Box and Grid components, and has a lot very good
abstractions in general. It uses a special unit system for margins, which we
tried to loosely replicate.

While our framework is none of those, we tried to cherry pick the most useful
abstractions to use in our code, and hopefully it makes UI development very
fun and productive.

## Component reference

> Notice: This documentation might be out of date, so always check the source
> code to see the most up-to-date information.

### `Box`

The Box component serves as a wrapper component for most of the CSS utility
needs. It creates a new DOM element, a `<div>` by default that can be changed
with the `as` property. Let's say you want to use a `<span>` instead:

```jsx
<Box as="span" m={1}>
  <Button />
</Box>
```

This works great when the changes can be isolated to a new DOM element.
For instance, you can change the margin this way.

However, sometimes you have to target the underlying DOM element.
For instance, you want to change the text color of the button. The Button
component defines its own color. CSS inheritance doesn't help.

To workaround this problem, the Box children accept a render props function.
This way, `Button` can pull out the `className` generated by the `Box`.

```jsx
<Box color="primary">
  {props => <Button {...props} />}
</Box>
```

Margin units which are used in `Box` are half font-size. In case of `tgui`,
default font size is `12px`, so each `m` unit is `6px` in size. If you need
more precision, you can always use fractional numbers.

Props:

- `as: string` - The component used for the root node.
- `color: string` - Applies an atomic `color-<name>` class to the element.
  - See `styles/atomic/color.scss` for color names.
- `height: number` - Box height.
- `inline: boolean` - Forces element to appear as an `inline-block`.
- `m: number` - Margin on all sides.
- `mb: number` - Bottom margin.
- `ml: number` - Left margin.
- `mr: number` - Right margin.
- `mt: number` - Top margin.
- `mx: number` - Horizontal margin.
- `my: number` - Vertical margin.
- `opacity: number` - Opacity, from 0 to 1.
- `width: number` - Box width.

### `Flex`

Quickly manage the layout, alignment, and sizing of grid columns, navigation, components, and more with a full suite of responsive flexbox utilities.

Inherits all properties from `Box`.

If you are new to or unfamiliar with flexbox, we encourage you to read this
[CSS-Tricks flexbox guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/).

Consists of two elements: `<Flex>` and `<Flex.Item>`. Both of them provide
the most straight-forward mapping to flex CSS properties as possible.

One of the most basic usage of flex, is to align certain elements
to the left, and certain elements to the right:

```jsx
<Flex>
  <Flex.Item>
    Button description
  </Flex.Item>
  <Flex.Item grow={1} />
  <Flex.Item>
    <Button content="Perform an action" />
  </Flex.Item>
</Flex>
```

Flex item with `grow` property serves as a "filler", to separate the other
two flex items as far as possible from each other.

Props:

- `direction: string` - This establishes the main-axis, thus defining the
direction flex items are placed in the flex container.
  - `row` (default) - left to right.
  - `row-reverse` - right to left.
  - `column` - top to bottom.
  - `column-reverse` - bottom to top.
- `wrap: string` - By default, flex items will all try to fit onto one line.
You can change that and allow the items to wrap as needed with this property.
  - `nowrap` (default) - all flex items will be on one line
  - `wrap` - flex items will wrap onto multiple lines, from top to bottom.
  - `wrap-reverse` - flex items will wrap onto multiple lines from bottom to top.
- `align: string` - Default alignment of all children.
  - `stretch` (default) - stretch to fill the container.
  - `start` - items are placed at the start of the cross axis.
  - `end` - items are placed at the end of the cross axis.
  - `center` - items are centered on the cross axis.
  - `baseline` - items are aligned such as their baselines align.
- `justify: string` - This defines the alignment along the main axis.
It helps distribute extra free space leftover when either all the flex
items on a line are inflexible, or are flexible but have reached their
maximum size. It also exerts some control over the alignment of items
when they overflow the line.
  - `flex-start` (default) - items are packed toward the start of the
  flex-direction.
  - `flex-end` - items are packed toward the end of the flex-direction.
  - `space-between` - items are evenly distributed in the line; first item is
  on the start line, last item on the end line
  - `space-around` - items are evenly distributed in the line with equal space
  around them. Note that visually the spaces aren't equal, since all the items
  have equal space on both sides. The first item will have one unit of space
  against the container edge, but two units of space between the next item
  because that next item has its own spacing that applies.
  - `space-evenly` - items are distributed so that the spacing between any two
  items (and the space to the edges) is equal.
  - TBD (not all properties are supported in IE11).

### `Flex.Item`

Props:

- `order: number` - By default, flex items are laid out in the source order.
However, the order property controls the order in which they appear in the
flex container.
- `grow: number` - This defines the ability for a flex item to grow if
necessary. It accepts a unitless value that serves as a proportion. It
dictates what amount of the available space inside the flex container the
item should take up. This number is unit-less and is relative to other
siblings.
- `shrink: number` - This defines the ability for a flex item to shrink
if necessary. Inverse of `grow`.
- `basis: string` - This defines the default size of an element before the
remaining space is distributed. It can be a length (e.g. `20%`, `5rem`, etc.),
an `auto` or `content` keyword.
- `align: string` - This allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. See: `<Flex>`.
