# tgui-next

## Pre-requisites

- [Node 12.x](https://nodejs.org)
- [Yarn](https://yarnpkg.com)
- [MSys2](https://www.msys2.org/) (optional)

## Workflow

For MSys2 users:

- `./build.sh --dev` - launch a dev server
- `./build.sh --mode=production` - produce production bundles

For everyone else:

Run `yarn install`, then:

- `yarn run watch` - launch a dev server
- `yarn run build` - produce production bundles

## Project structure

- `/packages` - home for reusable bits of functionality, where each folder
is a self-contained node module.
- `/packages/tgui/components` - Basic UI building blocks. Always stateless
and have maximum reusability.
- `/packages/tgui/interfaces` - Actual in-game interfaces. Take in-game state
via the `state` prop.
- `/packages/tgui/index.js` - Application entry point.
- `/packages/tgui/layout.js` - Root-level component, all in-game interfaces
go through it. Interface routing is also kept here in `routedComponents`
variable (it defines which interface component to load).

## Introduction to the new component system

This component framework is inspired by:

- [Semantic UI](https://react.semantic-ui.com/), which felt great because it
uses a very terse syntax and **semantic** (aka human readable)
naming conventions. Some things like `as`, `content` props, and shorthand
binary props, all are inspired straight from this framework.
- [Material UI](https://material-ui.com/components/box/), which has a very
good API, mainly for it's Box and Grid components, and has a lot very good
abstractions in general. It was designed for mobile use (React Native),
where `html5` elements are not really a thing, so having all `html`-like
components built into the framework is very convenient.

While our framework is none of those, we tried to cherry pick the most useful
abstractions to use in our code, and hopefully it makes UI development very
fun and productive.

## Component reference

> Notice: This documentation might be out of date, so always check the source
> code to see the most up-to-date information.

### `Box`

The Box component serves as a wrapper component for most of the CSS utility
needs. It creates a new DOM element, a `<div>` by default that can be changed
with the `as` property. Let's say you want to use a `<span>` instead:

```jsx
<Box as="span" m={1}>
  <Button />
</Box>
```

This works great when the changes can be isolated to a new DOM element.
For instance, you can change the margin this way.

However, sometimes you have to target the underlying DOM element.
For instance, you want to change the text color of the button. The Button
component defines its own color. CSS inheritance doesn't help.

To workaround this problem, the Box children accept a render props function.
This way, `Button` can pull out the `className` generated by the `Box`.

```jsx
<Box color="primary">
  {props => <Button {...props} />}
</Box>
```

Margin units which are used in `Box` are half font-size. In case of `tgui`,
default font size is `12px`, so each `m` unit is `6px` in size. If you need
more precision, you can always use fractional numbers.

Props:

- `as: string` - The component used for the root node.
- `color: string` - Applies an atomic `color-<name>` class to the element.
  - See `styles/atomic/color.scss` for color names.
- `height: number` - Box height.
- `inline: boolean` - Forces element to appear as an `inline-block`.
- `m: number` - Margin on all sides.
- `mb: number` - Bottom margin.
- `ml: number` - Left margin.
- `mr: number` - Right margin.
- `mt: number` - Top margin.
- `mx: number` - Horizontal margin.
- `my: number` - Vertical margin.
- `opacity: number` - Opacity, from 0 to 1.
- `width: number` - Box width.

### `Flex`

Quickly manage the layout, alignment, and sizing of grid columns, navigation, components, and more with a full suite of responsive flexbox utilities.

Inherits all properties from `Box`.

If you are new to or unfamiliar with flexbox, we encourage you to read this
[CSS-Tricks flexbox guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/).

Consists of two elements: `<Flex>` and `<Flex.Item>`. Both of them provide
the most straight-forward mapping to flex CSS properties as possible.

One of the most basic usage of flex, is to align certain elements
to the left, and certain elements to the right:

```jsx
<Flex>
  <Flex.Item>
    Button description
  </Flex.Item>
  <Flex.Item grow={1} />
  <Flex.Item>
    <Button content="Perform an action" />
  </Flex.Item>
</Flex>
```

Flex item with `grow` property serves as a "filler", to separate the other
two flex items as far as possible from each other.

Props:

- `direction: string` - This establishes the main-axis, thus defining the
direction flex items are placed in the flex container.
  - `row` (default) - left to right.
  - `row-reverse` - right to left.
  - `column` - top to bottom.
  - `column-reverse` - bottom to top.
- `wrap: string` - By default, flex items will all try to fit onto one line.
You can change that and allow the items to wrap as needed with this property.
  - `nowrap` (default) - all flex items will be on one line
  - `wrap` - flex items will wrap onto multiple lines, from top to bottom.
  - `wrap-reverse` - flex items will wrap onto multiple lines from bottom to top.
- `align: string` - Default alignment of all children.
  - `stretch` (default) - stretch to fill the container.
  - `start` - items are placed at the start of the cross axis.
  - `end` - items are placed at the end of the cross axis.
  - `center` - items are centered on the cross axis.
  - `baseline` - items are aligned such as their baselines align.
- `justify: string` - This defines the alignment along the main axis.
It helps distribute extra free space leftover when either all the flex
items on a line are inflexible, or are flexible but have reached their
maximum size. It also exerts some control over the alignment of items
when they overflow the line.
  - `flex-start` (default) - items are packed toward the start of the
  flex-direction.
  - `flex-end` - items are packed toward the end of the flex-direction.
  - `space-between` - items are evenly distributed in the line; first item is
  on the start line, last item on the end line
  - `space-around` - items are evenly distributed in the line with equal space
  around them. Note that visually the spaces aren't equal, since all the items
  have equal space on both sides. The first item will have one unit of space
  against the container edge, but two units of space between the next item
  because that next item has its own spacing that applies.
  - `space-evenly` - items are distributed so that the spacing between any two
  items (and the space to the edges) is equal.
  - TBD (not all properties are supported in IE11).

### `Flex.Item`

Props:

- `order: number` - By default, flex items are laid out in the source order.
However, the order property controls the order in which they appear in the
flex container.
- `grow: number` - This defines the ability for a flex item to grow if
necessary. It accepts a unitless value that serves as a proportion. It
dictates what amount of the available space inside the flex container the
item should take up. This number is unit-less and is relative to other
siblings.
- `shrink: number` - This defines the ability for a flex item to shrink
if necessary. Inverse of `grow`.
- `basis: string` - This defines the default size of an element before the
remaining space is distributed. It can be a length (e.g. `20%`, `5rem`, etc.),
an `auto` or `content` keyword.
- `align: string` - This allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. See: `<Flex>`.

### `???`

To be continued...
